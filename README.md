# 🌧️ Rain Typing Game

## 📖 프로젝트 개요

"Rain Typing Game"은 화면 상단에서 단어들이 빗방울처럼 떨어지는 고전적인 타이핑 게임입니다. 플레이어는 각 단어가 화면 바닥에 닿기 전에 정확히 타이핑하고 Enter 키를 눌러 제거해야 합니다.

이 프로젝트는 **클라이언트-서버 아키텍처**로 구현되었습니다.

* **서버:** 사용자 인증(회원가입, 로그인), 점수 제출, 리더보드 데이터 관리, 단어 목록 관리를 담당합니다. pthreads를 사용하여 여러 클라이언트 연결을 동시에 관리하며, 직접 시스템 콜을 사용한 파일 I/O로 데이터를 저장합니다.
* **클라이언트:** ncurses 라이브러리를 사용한 터미널 기반 UI를 제공하며, 해시 테이블과 멀티스레딩을 활용한 고성능 게임 로직을 구현합니다. SHA-256 암호화를 통한 보안 강화와 함께 서버와 통신합니다.

## ✨ 주요 기능

### 🔒 보안 강화
* **SHA-256 비밀번호 해싱:** OpenSSL 기반 암호화로 사용자 비밀번호 보안
* **중복 로그인 방지:** 동일 계정의 동시 접속 차단
* **메모리 보안:** 민감한 데이터 자동 정리

### 🎮 게임 시스템
* **다양한 단어 타입:**
  * **일반 단어 (흰색):** 기본 점수
  * **킬 단어 (빨간색):** 타이핑 시 게임 즉시 종료
  * **보너스 단어 (파란색):** 추가 점수 (+50점)
* **동적 난이도 조절:** 점수에 따른 단어 낙하 속도 증가
* **실시간 게임 상태:** 점수, 생명력, 레벨 표시

### 🏆 데이터 관리
* **리더보드 시스템:** 사용자별 최고 점수 기록
* **단어 목록 관리:** 서버에서 중앙 관리되는 단어 데이터베이스
* **영구 데이터 저장:** 직접 시스템 콜을 사용한 파일 I/O

### 🚀 성능 최적화
* **해시 테이블:** 활성 단어 중복 검사 최적화
* **멀티스레딩:** 각 단어의 독립적 애니메이션 처리
* **메모리 풀링:** 효율적인 메모리 관리

## 🛠 사용 기술

### 핵심 기술 스택
* **언어:** 순수 C (C99 표준)
* **암호화:** OpenSSL (SHA-256 해싱)
* **UI:** ncurses/ncursesw (유니코드 지원)
* **네트워킹:** POSIX 소켓 API
* **동시성:** POSIX Threads (pthreads)

### 시스템 프로그래밍 특징
* **Low-level 파일 I/O:** `open()`, `read()`, `write()`, `close()` 직접 사용
* **메모리 관리:** 커스텀 메모리 관리 시스템
* **시그널 처리:** SIGINT 핸들링을 통한 정상 종료
* **동기화 메커니즘:** 뮤텍스 기반 스레드 안전성

## 📁 프로젝트 구조

```
rain-typing-game/
├── client/
│   ├── src/
│   │   ├── auth_ui.c          # 인증 UI (SHA-256 해싱 포함)
│   │   ├── client_main.c      # 클라이언트 메인 로직
│   │   ├── client_network.c   # 네트워크 통신 모듈
│   │   ├── game_logic.c       # 게임 로직 (해시 테이블, 멀티스레딩)
│   │   └── leaderboard_ui.c   # 리더보드 UI
│   └── include/
│       ├── auth_ui.h
│       ├── client_globals.h   # 전역 변수 및 상수
│       ├── client_network.h
│       ├── game_logic.h
│       └── leaderboard_ui.h
├── server/
│   ├── src/
│   │   ├── auth_manager.c     # 인증 관리 (해시 검증)
│   │   ├── db_handler.c       # 파일 I/O (시스템 콜 사용)
│   │   ├── score_manager.c    # 점수 관리
│   │   ├── server_main.c      # 서버 메인 로직
│   │   ├── server_network.c   # 네트워크 핸들링
│   │   └── word_manager.c     # 단어 목록 관리
│   └── include/
│       ├── auth_manager.h
│       ├── db_handler.h
│       ├── score_manager.h
│       ├── server_network.h
│       └── word_manager.h
├── common/
│   ├── src/
│   │   └── hash_util.c        # SHA-256 암호화 유틸리티
│   └── include/
│       ├── hash_util.h
│       └── protocol.h         # 클라이언트-서버 프로토콜
├── data/                      # 서버 실행 시 자동 생성
│   ├── users.txt             # 사용자 계정 (해시된 비밀번호)
│   ├── scores.txt            # 점수 기록
│   └── words.txt             # 게임 단어 목록
├── Makefile                  # 빌드 스크립트
└── README.md
```

## 📋 사전 요구 사항

### 필수 패키지
```bash
# Ubuntu
sudo apt-get update
sudo apt-get install build-essential libncurses-dev libncursesw5-dev libssl-dev
```
## ⚙️ 컴파일 방법

### 전체 빌드
```bash
make
```
성공시 `bin/rain_client`와 `bin/rain_server` 실행 파일이 생성됩니다.

### 개별 빌드
```bash
# 클라이언트만 빌드
make client

# 서버만 빌드  
make server
```

### 정리
```bash
# 빌드 결과물 정리 (데이터 파일 보존)
make clean
```

## ▶️ 실행 방법

### 1. 서버 시작
```bash
./bin/rain_server
```
* 포트: 8080 (기본값)
* 로그: 클라이언트 연결/해제 상황 출력
* 종료: `Ctrl+C`

### 2. 클라이언트 시작
```bash
./bin/rain_client
```
* 서버 주소: 127.0.0.1:8080 (기본값)
* UI: ncurses 기반 터미널 인터페이스
* 종료: 메뉴에서 선택 또는 `Ctrl+C`

## 🎮 게임 플레이 가이드

### 인증 시스템
1. **회원가입**
   * 아이디: 3-31자 (영문, 숫자)
   * 비밀번호: SHA-256으로 자동 암호화
   * 중복 아이디 검사

2. **로그인**
   * 해시된 비밀번호 검증
   * 중복 로그인 방지
   * 세션 유지

### 게임 플레이
1. **기본 조작**
   * 단어 입력 후 `Enter` 또는 `Space`
   * `Backspace`: 입력 수정
   * `Ctrl+C`: 게임 종료 (메뉴로 복귀)

2. **단어 타입**
   * **흰색 (일반)**: 단어 길이만큼 점수
   * **빨간색 (킬)**: 타이핑 시 게임 즉시 종료
   * **파란색 (보너스)**: 기본 점수 + 50점

3. **난이도 시스템**
   * 점수 0-49: 레벨 1 (느림)
   * 점수 50-99: 레벨 2
   * 점수 100-149: 레벨 3
   * 점수 150-199: 레벨 4
   * 점수 200+: 레벨 5 (빠름)

### 점수 시스템
* **기본 점수**: 단어 길이
* **보너스 점수**: +50점 (파란색 단어)
* **생명력**: 5개 (단어가 바닥에 닿으면 -1)
* **게임 종료**: 생명력 0 또는 킬 단어 타이핑

## 🏗️ 아키텍처 특징

### 시스템 프로그래밍 기법
```c
// 직접 시스템 콜 사용 예시
int fd = open(filepath, O_RDONLY);
ssize_t bytes = read(fd, buffer, size);
close(fd);

// 해시 테이블 기반 단어 관리
typedef struct ActiveWordNode {
    char word[MAX_WORD_LEN];
    struct ActiveWordNode* next;
} ActiveWordNode;
```

### 성능 최적화
* **해시 테이블**: O(1) 단어 검색
* **스레드 풀**: 단어별 독립 스레드
* **메모리 풀**: 동적 할당 최소화
* **시스템 콜**: 표준 라이브러리 오버헤드 제거

### 보안 강화
* **SHA-256**: 단방향 해싱
* **메모리 정리**: 민감 데이터 자동 소거
* **입력 검증**: 버퍼 오버플로우 방지
